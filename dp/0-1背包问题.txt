要区分每次是能够拿一个完整包还是能够拿部分。
完整的：拿或者不拿
部分的：可以将包进行拆分。

使用贪心算法：
可以每次都只拿重量最小的包
可以每次都只拿价值最大的包
可以每次都只拿平均价值最大的包

但是这些不能解决问题，可以提供一些反例来进行证明。

实际的解法：动态规划。

对于给定的n个包，其中一个的重量是w[i],价值是p[i],限定重量是C

则可以使用一个二维表来进行记录，实际上就是拿到数据的最后一位  m[n][C]  c需要包含每一个重量值。

初始化的时候：
第一行都是0
第一列都是0

逐行遍历：如果m[i][j]=max(m[i-1][j],m[i-1][j-w[i]]+v[i])  
实际含义是： 不包含这个包的最大值，包含这个包的时候其他限制条件下的最大值，就是假设这个包是在里面的，那么i-1个包限定重量加上这个值，应该是多少。

实际实现的时候由于出现了j-w[i],所有在背包重量大于j-w[i]的时候不进行背包选择，只选择前面的。


理解最优子结构的问题，一定是在另一个的最优的基础上去进行取舍。


上面算法的时间复杂度和空间复杂度都是O(N*C)，但是实际空间上应该还有优化的空间，因为增加了一个包，可以从之前小重量的值当中得到，一维向量应该就够了


一维向量的基本思想实际上是：


之前的重量实际上是连续的，数值增加但是复杂度实际上是没有增加的。
所以只需要记录那些重量变化了的值就可以了
所谓变化了的实际上就是转折点。
关键的变化公式是，之前的结果，也就是每个转折点，增加W，增加p，然后得到新的转折点。
https://zhuanlan.zhihu.com/p/30959069

另外一个例子：
http://www.voidcn.com/article/p-npgfxjii-beo.html

非常经典的算法




如何取求解哪些物品放入了背包，如果和去掉这个物品相比，也就是没有这个物品的时候的 同样的y值，如果值相同则说明没有放到里面。要记录价值的变化